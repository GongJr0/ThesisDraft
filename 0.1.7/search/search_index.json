{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p><code>SymbolicDSGE</code> is a linear DSGE engine with a completely symbolic model specification. Through <code>SymPy</code>, model components are parsed into expressions that can be adjusted, decomposed, and analyzed. This allows things like searching model parameters in a grid, quickly modifying and testing parsed equations, and more; All parsed components of the model support overriding and recompiling. Although the library is currently in very early development, current functionality includes:</p> <ul> <li>YAML-based model configuration</li> <li>Parser with a <code>SymPy</code> backend</li> <li><code>linearsolve</code> based solver</li> <li>IRF path/plot generation</li> <li>Simulation</li> <li>Shock generation interface with support for all <code>SciPy</code> distributions</li> <li>Data retrieval helper for FRED API</li> <li>Data transformation functions (HP filters, detrending, etc.)</li> <li>Kalman Filter implementation</li> </ul>","tags":["info"]},{"location":"installation/","title":"Installation","text":"<p><code>SymbolicDSGE</code> can be installed via PyPI using the following command for use in a python environment.</p> <pre><code>pip install SymbolicDSGE\n</code></pre> <p>For people that want to modify or contribute to the project, forking the repository is advisable compared to a <code>pip install</code>. In the repository, you will find a <code>uv.lock</code> file. To interact with all components of the project using <code>uv sync --all-extras</code> is the quickest and easiest route. This will replicate the environment used at development and will include the <code>dev</code> dependency group for linting, auto formatting, etc.</p>","tags":["info"]},{"location":"Documentation/CompiledModel/","title":"CompiledModel","text":"<pre><code>@dataclass(frozen=True)\nclass CompiledModel()\n</code></pre> <p><code>CompiledModel</code> contains the model components mapped to numeric/vectorized/lambdified counterparts.</p> <p>Fields:</p> Name Type Description config <code>ModelConfig</code> Model config that was compiled. var_names <code>list[str]</code> Variables as strings. objective_eqs <code>list[sp.Expr]</code> Solver targets in symbolic representation. (not used in the solver) objective_funcs <code>list[Callable]</code> Solver objectives as standalone <code>Callable</code>s. equations <code>Callable</code> <code>objective_funcs</code> compiled into a single <code>Callable</code> target. (solver input) observable_names <code>list[str]</code> Observable variables as strings. observable_eqs <code>list[sp.Expr]</code> Measurement equations in symbolic representation. objective_funcs <code>list[Callable]</code> Measurement equations as <code>Callable</code>s. n_state <code>int</code> Number of state variables. n_exog <code>int</code> Number of exogenous variables. <p> </p> <p>Methods:</p> Signature Return Type Description <code>.to_dict()</code> <code>dict</code> <code>CompiledModel</code> in dictionary form."},{"location":"Documentation/DSGESolver/","title":"DSGESolver","text":"<pre><code>class DSGESolver(model_config: ModelConfig, t: sp.Symbol = sp.Symbol('t', integer=True))\n</code></pre> <p>Class responsible for model compilation and solution.</p> <p>Attributes:</p> Name Type Description model_config <code>ModelConfig</code> Configuration object to be compiled/solved. t <code>sp.Symbol</code> Time symbol used in model components. <p>Methods:</p> Signature Return Type Description <code>.compile(variable_order: list[sp.Function], n_state: int = None, n_exog: int = None, params_order: list[str] = None)</code> <code>CompiledModel</code> Produces a <code>CompiledModel</code> object respecting the given orders. <code>n_exog</code> and <code>n_state</code> must be supplied. <code>.solve(compiled: CompiledModel, parameters:dict[str, float] = None, steady_state: ndarray[float] | dict[str, float] = None, log_linear: bool = False)</code> <code>SolvedModel</code> Solves the given compiled model and returns a <code>SolvedModel</code> object."},{"location":"Documentation/ModelConfig/","title":"ModelConfig","text":"<pre><code>@dataclass\nclass ModelConfig()\n</code></pre> <p><code>ModelConfig</code> stores the parsed model as <code>SymPy</code> objects/expressions.</p> <p>Fields:</p> Name Type Description name <code>str</code> Model name. variables <code>list[sp.Function]</code> Variables as functions of time. constrained <code>dict[Function, bool]</code> Dictionary mapping functions to constraint status. parameters <code>list[sp.Symbol]</code> Model parameters as symbols. shocks <code>list[sp.Symbol]</code> Shock variables as symbols. observables <code>list[sp.Symbol]</code> Observable variables as symbols. equations <code>Equations</code> <code>dataclass</code> containing model, constraint, and observable equations. calibration <code>Calib</code> <code>dataclass</code> of parameter calibrations and shock-to-sigma mappings."},{"location":"Documentation/ModelParser/","title":"ModelParser","text":"<pre><code>class ModelParser(config_path: str | pathlib.Path)\n</code></pre> <p><code>ModelParser</code> reads a given YAML configuration file (see configuration guide) and parses the contents into a <code>ModelConfig</code> object.</p> <p>Parameters:</p> Name Type Description config_path <code>str | pathlib.Path</code> Path to the YAML config file. config <code>ModelConfig</code> Parsed config object. <p> </p> <p>Methods:</p> Signature Return Type Description <code>.from_yaml()</code> <code>ModelConfig</code> Reads the file and populates <code>ModelParser.config</code>. Runs at <code>__init__</code>. <code>.get()</code> <code>ModelConfig</code> Returns the currently parsed model config. <code>.to_pickle(filepath: str | pathlib.Path)</code> <code>None</code> Serializes the current <code>ModelConfig</code> and saves to <code>filepath</code>."},{"location":"Documentation/Shock/","title":"Shock","text":"<p>[TO BE PUBLISHED]</p>"},{"location":"Documentation/SolvedModel/","title":"SolvedModel","text":"<pre><code>@dataclass(frozen=True)\nclass SolvedModel()\n</code></pre> <p><code>SolvedModel</code> contains the policy/transition matrices and relevant methods.</p> <p>Fields:</p> Name Type Description compiled <code>CompiledModel</code> The compiled model object that resulted in the current solution. policy <code>linearsolve.model</code> The output of the solver backend. Includes stability indicators, eigen values, and raw output of the solver. A <code>np.ndarray</code> The discovered state-transition matrix. B <code>np.ndarray</code> The discovered innovation impact matrix. <p> </p> <p>Methods:</p> Signature Return Type Description <code>.sim(T: int, shocks: str, Union[Callable[[float | list[float]], np.ndarray], np.ndarray], shock_scale: float = 1.0, x0: np.ndarray = None, observables: bool = False)</code> <code>dict[str, np.ndarray]</code> Returns the simulated path defined by the given inputs. <code>.irf(shocks: list[str], T: int, scale: float = 1.0, obsevables: bool = False)</code> <code>dict[str, np.ndarray]</code> returns the IRF paths with shocks to specified variable(s). <code>.transition_plot(T: int, shocks: list[str], scale: float = 1.0, obsevables: bool = False)</code> <code>None</code> Display the plot of transition paths generated by the specified shocks. <code>.to_dict()</code> <code>dict</code> Dictionary representation of the class instance."},{"location":"Documentation/Utilities/FRED/","title":"FRED","text":"<p>[TO BE PUBLISHED]</p>"},{"location":"Documentation/Utilities/KalmanFilter/","title":"KalmanFilter","text":"<p>[TO BE PUBLISHED]</p>"},{"location":"Documentation/Utilities/math_utils/","title":"math_utils","text":"<p>[TO BE PUBLISHED]</p>"},{"location":"Guides/config_guide/","title":"Configuration Guide","text":"<p>TL;DR You can see an example config here.</p> <p><code>SymbolicDSGE</code> models are configured through a YAML-file. Similar to many familiar DSGE engines, the configuration contains:</p> <ul> <li>Parameter declarations</li> <li>Constraint definitions</li> <li>Model equations</li> <li>Measurement equations (For post-solution observables)</li> <li>Parameter calibration</li> <li>Shock symbol declarations</li> </ul> <p>This guide contains detailed information about config sections, how they are parsed, and the conventions users are expected to follow for correct parsing. Ordering of fields do not matter for the parser, however ordering of the components can change the model behavior. We will start with an empty config and build components to create a valid model in this guide.</p> <p>To start with, the configuration accepts a <code>name</code> field to specify the model's alias. This name is accessible in the parsed model but never used; it remains in the model object as a reference for users.</p> <pre><code>name: \"Test Model\"\n</code></pre>","tags":["guide"]},{"location":"Guides/config_guide/#variables","title":"Variables","text":"<p>The <code>variables</code> field contains the names for all primary model variables. (no time indices or parameters) It is declared as a list and the ordering of variables will be respected in the solver unless explicitly given a separate ordering. In addition to variable names, each variable requires an explicit boolean entry in the <code>constrained</code> field. Having this toggle allows the constraint equations to be predefined in the config but only used when explicitly enabled.</p> <p>Variables are declared as follows: <pre><code>variables: [g, z, r, Pi, x]\nconstrained:\n    g: false\n    z: false\n    r: false\n    x: false\n    Pi: false\n</code></pre></p>","tags":["guide"]},{"location":"Guides/config_guide/#parameters","title":"Parameters","text":"<p>Parameters are \"constants\" that appear in the model equations in some capacity. Common examples of parameters are:</p> <ul> <li>Shock persistence terms</li> <li>Shock variances/covariances</li> <li>Steady state values</li> <li>model parameters such as the discount factor (often \\(\\beta\\))</li> </ul> <p>Ordering of the parameters does not matter in the configuration file. The <code>parameters</code> field is again declared as a list. <pre><code>parameters: [beta, kappa, tau_inv,\n             psi_pi, psi_x, rho_r,\n             rho_g, rho_z,\n             pi_star, r_star,\n             sig_R, sig_g, sig_z,\n             rho_gz]\n</code></pre></p> <p>Importantly, the current config expects all shock sigmas to be defined as <code>f\"sig_{varname}\"</code> and covariance terms as <code>f\"rho_{var1}{var2}\"</code>. The mapping layer will be updated to accept any variable name in future iterations, but the current config falls back to defaults if shocks terms are not accompanied by a <code>sig_</code> and/or <code>rho_</code> parameter.</p> <p>NOTE: <code>SymbolicDSGE</code> currently expects each parameter to have known values. estimation/inference will be implemented but are not accessible as of now.</p>","tags":["guide"]},{"location":"Guides/config_guide/#shocks","title":"Shocks","text":"<p>Shocks are the symbols that represent the stochastic components of the model. A shock symbol is separate from its variance/covariance and is used to indicate where a respective innovation should be applied in the model equations.</p> <pre><code>shocks: [e_g, e_z, e_R]\n</code></pre> <p>Shock realizations are only injected when the user selects them at simulation time. Therefore, declaring extra variables here and including them in the model equations can be used to test multiple shock configurations from a single model config.</p>","tags":["guide"]},{"location":"Guides/config_guide/#observables","title":"Observables","text":"<p>Observables map model units to real life variables via equations. For the <code>observables</code> field we only declare the names we desire to use as observable variables. <pre><code>observables: [Infl, Rate]\n</code></pre></p>","tags":["guide"]},{"location":"Guides/config_guide/#equations","title":"Equations","text":"<p>Equations contain the bulk of model dynamics. In <code>SymbolicDSGE</code> the field is used as a parent to model equations, constraints, and observable equations. We declare the necessary fields: <pre><code>equations:\n    model: ...\n    constraint: ...\n    observables: ...\n</code></pre> The equations field treats all variables as a function of time; to refer to past, current, and future observations we use <code>x(t-1)</code>, <code>x(t)</code>, and <code>x(t+1)</code> respectively.</p>","tags":["guide"]},{"location":"Guides/config_guide/#model-equations","title":"Model Equations","text":"<p>This field contains the state-space definition. Multiple equations are supplied to form all necessary interactions. <pre><code>equations:\n    model:\n        - Pi(t) = beta*Pi(t+1) + kappa*x(t) + z(t) # (1)!\n\n        - x(t) = x(t+1) - tau_inv*(r(t) - Pi(t+1)) + g(t) # (2)!\n\n        - r(t) = rho_r*r(t-1) + (1 - rho_r)*(psi_pi*Pi(t) + psi_x*x(t)) + e_R # (3)!\n\n        - g(t) = rho_g*g(t-1) + e_g # (4)!\n\n        - z(t) = rho_z*z(t-1) + e_z # (5)!\n    constraint: ...\n    observables: ...\n</code></pre></p> <ol> <li>New Keynesian Philips Curve (NKPC)</li> <li>IS/Euler Equation</li> <li>Taylor Rule</li> <li>Demand Shock</li> <li>Cost-Push Shock</li> </ol> <p>Here, we use these variables and parameters that we defined to create the namespace.</p>","tags":["guide"]},{"location":"Guides/config_guide/#constraints","title":"Constraints","text":"<p>The constraints field is available and parsed in <code>SymbolicDSGE</code>. However, the constraints are currently not supported in the solver and therefore are not enforced. The <code>constraint</code> field takes a <code>{variable: equation, ...}</code> style dictionary. For correctness, we will leave the field empty in the example config. <pre><code>equations:\n    model:\n        - Pi(t) = beta*Pi(t+1) + kappa*x(t) + z(t)\n\n        - x(t) = x(t+1) - tau_inv*(r(t) - Pi(t+1)) + g(t)\n\n        - r(t) = rho_r*r(t-1) + (1 - rho_r)*(psi_pi*Pi(t) + psi_x*x(t)) + e_R\n\n        - g(t) = rho_g*g(t-1) + e_g\n\n        - z(t) = rho_z*z(t-1) + e_z\n    constraint: {...}\n    observables: ...\n</code></pre></p>","tags":["guide"]},{"location":"Guides/config_guide/#observables_1","title":"Observables","text":"<p>This field contains the mappings of model variables to real-life observed variables. In our example, we defined two observables in the namespace; and we will define the equations to construct them here. As a note, observable equations are expected to correspond to current time. All past observables will be known at time <code>t</code>, and the future values are not supported as \"observables\" by definition. <pre><code>equations:\n    model:\n        - Pi(t) = beta*Pi(t+1) + kappa*x(t) + z(t)\n\n        - x(t) = x(t+1) - tau_inv*(r(t) - Pi(t+1)) + g(t)\n\n        - r(t) = rho_r*r(t-1) + (1 - rho_r)*(psi_pi*Pi(t) + psi_x*x(t)) + e_R\n\n        - g(t) = rho_g*g(t-1) + e_g\n\n        - z(t) = rho_z*z(t-1) + e_z\n    constraint: {...}\n    observables:\n        Infl: 4*Pi(t) + pi_star # (1)!\n\n        Rate: 4*r(t) + (r_star + pi_star) # (2)!\n</code></pre></p> <ol> <li>Annualized inflation from quarterly gap</li> <li>Annualized nominal rate from quarterly gap. </li> </ol>","tags":["guide"]},{"location":"Guides/config_guide/#calibration","title":"Calibration","text":"<p>The <code>calibration</code> field stores values and shock variance specifications to annotate the corresponding values of all model components except the variables. The field is a parent containing two sub-fields: <pre><code>calibration:\n    parameters: ...\n    shocks: ...\n</code></pre></p>","tags":["guide"]},{"location":"Guides/config_guide/#parameters_1","title":"Parameters","text":"<p>This section is used to define the known values of model parameters.  All parameters defined in the namespace must (for now) have a value entry here. <pre><code>calibration:\n    parameters:\n        beta: 0.99\n\n        psi_pi: 2.19\n        psi_x: 0.30\n        rho_r: 0.84\n\n        pi_star: 3.43\n        r_star: 3.01\n\n        kappa: 0.58\n        tau_inv: 1.86\n\n        rho_g: 0.83\n        rho_z: 0.85\n        rho_gz: 0.36\n\n        sig_R: 0.18\n        sig_g: 0.18\n        sig_z: 0.64\n    shocks: ...\n</code></pre></p>","tags":["guide"]},{"location":"Guides/config_guide/#shocks_1","title":"Shocks","text":"<p>The shocks section maps shock variances to the corresponding terms in model equations. All terms defined in the shock namespace must have a value here. <pre><code>calibration:\n    parameters:\n        beta: 0.99\n\n        psi_pi: 2.19\n        psi_x: 0.30\n        rho_r: 0.84\n\n        pi_star: 3.43\n        r_star: 3.01\n\n        kappa: 0.58\n        tau_inv: 1.86\n\n        rho_g: 0.83\n        rho_z: 0.85\n        rho_gz: 0.36\n\n        sig_R: 0.18\n        sig_g: 0.18\n        sig_z: 0.64\n    shocks:\n        e_g: sig_g\n        e_z: sig_z\n        e_R: sig_R\n</code></pre></p>","tags":["guide"]},{"location":"Guides/config_guide/#conclusion","title":"Conclusion","text":"<p>With all components defined, the configuration file now fully specifies a solvable symbolic DSGE model. The parser will construct the symbolic state-space representation, apply calibration, and prepare the model for solution and simulation. For future reference or a read-made boilerplate, you can visit this link to see a test configuration in the <code>SymbolicDSGE</code> repository.</p>","tags":["guide"]},{"location":"Guides/quickstart/","title":"Quick Start Guide","text":"<p>TL;DR You can find a demonstration notebook here.</p> <p>This guide will follow the steps necessary to get from model parsing to simulation. We will use a pre-defined config file (accessible in the repository) <code>\"MODELS/POST82.yaml\"</code>.</p>","tags":["guide"]},{"location":"Guides/quickstart/#reading-model-configuration","title":"Reading Model Configuration","text":"<p>The configuration files are parsed by the <code>SymbolicDSGE.ModelParser</code> class. The class provides a <code>.get()</code> method to return a <code>ModelConfig</code> object.</p> <pre><code>from SymbolicDSGE import ModelParser\nfrom sympy import Matrix\nfrom warnings import simplefilter, catch_warnings\n\nmodel = ModelParser(\"MODELS/POST82.yaml\").get()\n\nwith catch_warnings(): # (1)!\n    simplefilter(action=\"ignore\")\n    mat = Matrix(model.equations.model)\nmat\n</code></pre> <ol> <li>Equations in a <code>sp.Matrix</code> are deprecated, this is only used as a pretty print function.</li> </ol> <p>We've read the config and displayed the equations in a matrix:</p> \\[     \\left[\\begin{matrix}\\Pi{\\left(t \\right)} = \\beta \\Pi{\\left(t + 1 \\right)} + \\kappa x{\\left(t \\right)} + z{\\left(t \\right)}\\\\x{\\left(t \\right)} = - \\tau_{inv} \\left(- \\Pi{\\left(t + 1 \\right)} + r{\\left(t \\right)}\\right) + g{\\left(t \\right)} + x{\\left(t + 1 \\right)}\\\\r{\\left(t \\right)} = e_{R} + \\rho_{r} r{\\left(t - 1 \\right)} + \\left(1 - \\rho_{r}\\right) \\left(\\psi_{\\pi} \\Pi{\\left(t \\right)} + \\psi_{x} x{\\left(t \\right)}\\right)\\\\g{\\left(t \\right)} = e_{g} + \\rho_{g} g{\\left(t - 1 \\right)}\\\\z{\\left(t \\right)} = e_{z} + \\rho_{z} z{\\left(t - 1 \\right)}\\end{matrix}\\right] \\] <p>We can see that all variables are converted to <code>SymPy</code> objects (symbols/functions) and are accessible through the <code>ModelConfig</code> interface.</p>","tags":["guide"]},{"location":"Guides/quickstart/#compilation","title":"Compilation","text":"<p>In compilation, the symbolic model is projected into a functionalized and completely numeric form. Time dependent variable are separated and equations are written as lambda objectives. Finally, the solver backend <code>linearsolver</code> is exposed to a single function representing all model equations.</p> <pre><code>from SymbolicDSGE import DSGESolver\n\nsolver = DSGESolver(model)\ncompiled = solver.compile(\n    variable_order=None, # (1)!\n    params_order=None, # (2)!\n    n_state=3, # (3)!\n    n_exog=2, # (4)!\n)\n\nprint(\"Equations with symbols removed: \\n\", \"\\n\".join(map(str, compiled.objective_eqs)))\nprint(\"\\n\")\nprint(\"Equations as passed to the solver: \\n\", compiled.equations)\n</code></pre> <ol> <li><code>None | list[Function]</code>. <code>None</code> uses the order in the config file.</li> <li><code>None | list[str]</code>. <code>None</code> uses the order in the config file.</li> <li>Number of state variables (must be supplied)</li> <li>Number of exogenous variables (must be supplied)</li> </ol> <p>At compilation, the equations are transformed as shown in the code output: <pre><code>Equations with symbols removed: \n -beta*fwd_Pi + cur_Pi - cur_x*kappa - cur_z\n-cur_g + cur_x - fwd_x + tau_inv*(cur_r - fwd_Pi)\n-cur_r*rho_r - e_R + fwd_r + (rho_r - 1)*(fwd_Pi*psi_pi + fwd_x*psi_x)\n-cur_g*rho_g - e_g + fwd_g\n-cur_z*rho_z - e_z + fwd_z\n\n\nEquations as passed to the solver: \n &lt;function DSGESolver.compile.&lt;locals&gt;.equations at 0x0000012D16AB5B20&gt;\n</code></pre></p> <p>IMPORTANT: The solver relies on the exogenous variables being placed in the first indices. You should ensure the first <code>n_exog</code> entries of the order correctly map to the exogenous variables. (either through the config or via the ordering) </p>","tags":["guide"]},{"location":"Guides/quickstart/#solution","title":"Solution","text":"<p>The solution step takes steady-state values and optionally parameter calibrations to provide a <code>SolvedModel</code>.</p> <pre><code>from numpy import float64, array\n\nsol = solver.solve(\n    compiled,\n    parameters=None, # (1)!\n    steady_state=array([0.0, 0.0, 0.0, 0.0, 0.0], dtype=float64),\n    log_linear=False,\n)\nprint(\"Is stable: \", not sol.policy.stab)  # (2)! \nprint(\"Eigenvalues: \", sol.policy.eig)\n</code></pre> <ol> <li><code>None | dict[str, float]</code>. <code>None</code> uses the values in <code>ModelConfig.calibration</code></li> <li>stable if <code>sol.policy.stab == 0</code></li> </ol> <pre><code>Is stable:  True\nEigenvalues:  [0.27920118+0.j 0.83000003+0.j 0.84999992+0.j 2.56517116+0.j\n 1.18470582+0.j] (1)\n</code></pre> <ol> <li>Complex numbers are an artifact of <code>linearsolve</code>. All relevant matrices are cast to reals with <code>np.real_if_close</code></li> </ol>","tags":["guide"]},{"location":"Guides/quickstart/#inspecting-model-dynamics","title":"Inspecting Model Dynamics","text":"<p>While we can check the matrices directly, we can also use the built-in methods <code>SolvedModel.irf</code> and <code>SolvedModel.transition_plot</code> to display the dynamics.</p> <pre><code>irf_dict = sol.irf(\n    T=25,\n    shocks=[\"g\", \"z\"],\n    scale=1.0,  # (1)!\n    observables=True,  # (2)!\n)\nsol.transition_plot(\n    T=25,\n    shocks=[\"g\", \"z\"],\n    scale=1.0,\n    observables=True,\n)\nirf_dict[\"z\"] # (3)!\n</code></pre> <ol> <li><code>shock = sig_var * scale</code></li> <li>Include observables in output.</li> <li>Path of the variable <code>z</code>.</li> </ol> <p>This produces the outputs: </p> <pre><code>array([0.        , 0.64      , 0.54399995, 0.46239991, 0.39303989,\n       0.33408388, 0.28397127, 0.24137556, 0.2051692 , 0.17439381,\n       0.14823472, 0.1259995 , 0.10709957, 0.09103462, 0.07737942,\n       0.0657725 , 0.05590662, 0.04752063, 0.04039253, 0.03433365,\n       0.0291836 , 0.02480605, 0.02108514, 0.01792237, 0.01523401,\n       0.01294891])\n</code></pre>","tags":["guide"]},{"location":"Guides/quickstart/#simulation","title":"Simulation","text":"<p><code>SolvedModel</code> also supplies a <code>.sim()</code> method for simulations. The method simulates <code>T</code> steps given an initial state array and a shock specification.</p> <p>Shock specifications can take two basic forms.</p> <ul> <li>A callable returning the complete shock array: <code>Callable[[float | list[float]], ndarray[float64]]</code></li> <li>A <code>np.ndarray</code> of innovations</li> </ul> <p>Either specification is delivered to <code>.sim</code> in a dictionary corresponding to the variable the innovations are meant to effect. In case of multiple shocks with correlation the key for the dictionary uses <code>\"g,z\"</code> syntax. In correlated cases, the <code>Callable</code> option input should take a covariance matrix while the array option must be of shape <code>(T, n_correlated_shocks)</code>. (order should match the dictionary key)</p> <p><code>SymbolicDSGE.Shock</code> is an interface simplifying the shock generation process. It can produce <code>Callable</code> generators for both univariate and multivariate shocks. The class has support for all <code>SciPy</code> distributions from the <code>rv_generic</code> and <code>multi_rv_generic</code> hierarchies. Alongside <code>SciPy</code> support, a custom distribution implementing the <code>.rvs</code> method are supported through the pass-through of distribution args/kwargs.</p> <pre><code>from SymbolicDSGE import Shock\n\nT = 200\nshock_gen = lambda seed: Shock( # (1)!\n    T=T,\n    dist=\"norm\",\n    multivar=True,\n    seed=seed, # (2)!\n    dist_kwargs={ # (3)!\n        \"mean\": [0.0, 0.0],\n    },\n).shock_generator() # (4)!\n\nsim_shocks = {\n    \"g,z\": shock_gen(seed=1) # (5)!\n}\n</code></pre> <ol> <li>Notice the seed argument to the class being parametrized through a lambda. This step is not necessary for functionality. It saves the code of declaring two instances with different seeds if two shocks share variances.</li> <li>Seed is passed through here, the code below would operate the same if we used <code>seed=1</code> instead of using a lambda.</li> <li>The <code>kwargs</code> specified here are passed to the distribution object in the backend (to <code>SciPy</code>'s rvs methods in this case)</li> <li><code>shock_generator</code> produces the <code>Callable</code> object from the parameters given at class initialization. The methods either accept a float <code>sig_</code> or a covariance matrix <code>cov</code> created inside the <code>.sim</code> method.</li> <li>The value in this pair is a standalone function that does not depend on model parameters. Once created it can be used with any arbitrary <code>sig_</code> or <code>cov</code> to produce shock arrays as necessary.</li> </ol> <p><code>shock_gen()</code> returns a callable that <code>.sim</code> uses in the simulation loop to produce shocks. With the shocks produced, we can use simulate non-deterministic paths as follows:</p> <pre><code>import pandas as pd\n\nsim_data = sol.sim(\n    T=T,\n    x0=array([0.0, 0.0, 0.0, 0.0, 0.0], dtype=float64),  # (1)!\n    shocks=sim_shocks,\n    shock_scale=1.0,\n    observables=True,\n)\ndel sim_data[\"_X\"]  # (2)!\npd.DataFrame(sim_data).head(10)\n</code></pre> <ol> <li>Simulation starts at steady state</li> <li><code>\"_X\"</code> is a <code>ndarray</code> of all non-observable states for each time t. It is deleted here for code brevity in producing a <code>DataFrame</code>.</li> </ol> g z r Pi x Infl Rate 0 0 0 0 0 0 3.43 6.44 1 0.0113 1.0502 0 2.0097 0.4527 11.469 6.44 2 -0.2055 0.5741 0.205 -0.4441 -1.6807 1.6538 7.2601 3 -0.4925 1.0832 0.1083 0.2587 -1.8046 4.4646 6.873 4 -0.4139 2.0507 0.0962 2.3427 -1.0963 12.8009 6.8249 5 -0.3628 1.9517 0.3014 1.2818 -2.2254 8.557 7.6456 6 -0.5415 2.6315 0.3544 1.8491 -2.8505 10.8264 7.8577 7 -0.5357 2.0374 0.4482 0.2843 -3.6404 4.5671 8.233 8 -0.5484 2.477 0.362 1.503 -2.9801 9.442 7.8881 9 -0.6129 2.0109 0.4187 0.1822 -3.7172 4.1587 8.1148 <p>Alternative to a DataFrame, we can also plot the simulated paths:</p> <p><pre><code>from numpy import ceil, sqrt\nimport matplotlib.pyplot as plt\n\nfig_square = ceil(sqrt(len(sim_data))).astype(int)\nsize = (4 * fig_square, 3 * fig_square)\nfig, ax = plt.subplots(fig_square, fig_square, figsize=size)\nax = ax.flatten()\n\nwhile len(ax) &gt; len(sim_data):\n    fig.delaxes(ax[-1])\n    ax = ax[:-1]\n\nfor i, (var, path) in enumerate(sim_data.items()):\n    ax[i].plot(path)\n    ax[i].set_title(var)\n    ax[i].grid(linestyle=\":\")\nplt.suptitle(f\"Simulation over {T} periods with stochastic shocks\", fontsize=16)\nplt.tight_layout()\n</code></pre> </p>","tags":["guide"]},{"location":"Guides/quickstart/#further-steps","title":"Further Steps","text":"<p>This guide covers the basic capabilities and usage of <code>SymbolicDSGE</code>. Further tools include <code>SymbolicDSGE.FRED</code> for easy U.S. macro data retrieval, <code>SymbolicDSGE.math_utils</code> for basic detrending, HP filters, etc. and <code>SymbolicDSGE.KalmanFilter</code> for a one-sided Kalman Filter implementation. (standalone as of now but easy model integration interface will be developed) If you've read to this point and would like to inspect/interact with the code this guide refers to, you can visit this link to the file.</p>","tags":["guide"]}]}